
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cppcheck - HTML report - [project name]</title>
    <link rel="stylesheet" href="style.css">
    <style>
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #ffffff; }
.highlight .c { color: #888888 } /* Comment */
.highlight .err { color: #FF0000; background-color: #FFAAAA } /* Error */
.highlight .k { color: #008800; font-weight: bold } /* Keyword */
.highlight .o { color: #333333 } /* Operator */
.highlight .cm { color: #888888 } /* Comment.Multiline */
.highlight .cp { color: #557799 } /* Comment.Preproc */
.highlight .c1 { color: #888888 } /* Comment.Single */
.highlight .cs { color: #cc0000; font-weight: bold } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0044DD } /* Generic.Traceback */
.highlight .kc { color: #008800; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #333399; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #6600EE; font-weight: bold } /* Literal.Number */
.highlight .s { background-color: #fff0f0 } /* Literal.String */
.highlight .na { color: #0000CC } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #BB0066; font-weight: bold } /* Name.Class */
.highlight .no { color: #003366; font-weight: bold } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #880000; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #FF0000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0066BB; font-weight: bold } /* Name.Function */
.highlight .nl { color: #997700; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #007700 } /* Name.Tag */
.highlight .nv { color: #996633 } /* Name.Variable */
.highlight .ow { color: #000000; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
.highlight .mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
.highlight .mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
.highlight .mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
.highlight .mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
.highlight .sb { background-color: #fff0f0 } /* Literal.String.Backtick */
.highlight .sc { color: #0044DD } /* Literal.String.Char */
.highlight .sd { color: #DD4422 } /* Literal.String.Doc */
.highlight .s2 { background-color: #fff0f0 } /* Literal.String.Double */
.highlight .se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
.highlight .sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
.highlight .si { background-color: #eeeeee } /* Literal.String.Interpol */
.highlight .sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
.highlight .sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
.highlight .s1 { background-color: #fff0f0 } /* Literal.String.Single */
.highlight .ss { color: #AA6600 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #336699 } /* Name.Variable.Class */
.highlight .vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
.highlight .vi { color: #3333BB } /* Name.Variable.Instance */
.highlight .il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
    </style>
    <script language="javascript">
      function getStyle(el,styleProp) {
        if (el.currentStyle)
          var y = el.currentStyle[styleProp];
        else if (window.getComputedStyle)
          var y = document.defaultView.getComputedStyle(el,null).getPropertyValue(styleProp);
        return y;
      }
      function toggle() {
        var el = this.expandable_content;
        var mark = this.expandable_marker;
        if (el.style.display == "block") {
          el.style.display = "none";
          mark.innerHTML = "[+]";
        } else {
          el.style.display = "block";
          mark.innerHTML = "[-]";
        }
      }
      function init_expandables() {
        var elts = document.getElementsByClassName("expandable");
        for (var i = 0; i < elts.length; i++) {
          var el = elts[i];
          var clickable = el.getElementsByTagName("span")[0];
          var marker = clickable.getElementsByClassName("marker")[0];
          var content = el.getElementsByClassName("content")[0];
          var width = clickable.clientWidth - parseInt(getStyle(content, "padding-left")) - parseInt(getStyle(content, "padding-right"));
          content.style.width = width + "px";
          clickable.expandable_content = content;
          clickable.expandable_marker = marker;
          clickable.onclick = toggle;
        }
      }
    </script>
  </head>
  <body onload="init_expandables()">
      <div id="header">
        <h1>Cppcheck report - [project name]: ../../godot/drivers/builtin_openssl2/ssl/s3_cbc.c </h1>
      </div>
      <div id="menu" dir="rtl">
       <p id="filename"><a href="index.html">Defects:</a> s3_cbc.c</p>
<a href='379.html#line-460'> variableScope 460</a>
      </div>
      <div id="content">
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790</pre></div></td><td class="code"><div class="highlight"><pre><a name="line-1"></a><span class="cm">/* ssl/s3_cbc.c */</span>
<a name="line-2"></a><span class="cm">/* ====================================================================</span>
<a name="line-3"></a><span class="cm"> * Copyright (c) 2012 The OpenSSL Project.  All rights reserved.</span>
<a name="line-4"></a><span class="cm"> *</span>
<a name="line-5"></a><span class="cm"> * Redistribution and use in source and binary forms, with or without</span>
<a name="line-6"></a><span class="cm"> * modification, are permitted provided that the following conditions</span>
<a name="line-7"></a><span class="cm"> * are met:</span>
<a name="line-8"></a><span class="cm"> *</span>
<a name="line-9"></a><span class="cm"> * 1. Redistributions of source code must retain the above copyright</span>
<a name="line-10"></a><span class="cm"> *    notice, this list of conditions and the following disclaimer.</span>
<a name="line-11"></a><span class="cm"> *</span>
<a name="line-12"></a><span class="cm"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<a name="line-13"></a><span class="cm"> *    notice, this list of conditions and the following disclaimer in</span>
<a name="line-14"></a><span class="cm"> *    the documentation and/or other materials provided with the</span>
<a name="line-15"></a><span class="cm"> *    distribution.</span>
<a name="line-16"></a><span class="cm"> *</span>
<a name="line-17"></a><span class="cm"> * 3. All advertising materials mentioning features or use of this</span>
<a name="line-18"></a><span class="cm"> *    software must display the following acknowledgment:</span>
<a name="line-19"></a><span class="cm"> *    &quot;This product includes software developed by the OpenSSL Project</span>
<a name="line-20"></a><span class="cm"> *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)&quot;</span>
<a name="line-21"></a><span class="cm"> *</span>
<a name="line-22"></a><span class="cm"> * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to</span>
<a name="line-23"></a><span class="cm"> *    endorse or promote products derived from this software without</span>
<a name="line-24"></a><span class="cm"> *    prior written permission. For written permission, please contact</span>
<a name="line-25"></a><span class="cm"> *    openssl-core@openssl.org.</span>
<a name="line-26"></a><span class="cm"> *</span>
<a name="line-27"></a><span class="cm"> * 5. Products derived from this software may not be called &quot;OpenSSL&quot;</span>
<a name="line-28"></a><span class="cm"> *    nor may &quot;OpenSSL&quot; appear in their names without prior written</span>
<a name="line-29"></a><span class="cm"> *    permission of the OpenSSL Project.</span>
<a name="line-30"></a><span class="cm"> *</span>
<a name="line-31"></a><span class="cm"> * 6. Redistributions of any form whatsoever must retain the following</span>
<a name="line-32"></a><span class="cm"> *    acknowledgment:</span>
<a name="line-33"></a><span class="cm"> *    &quot;This product includes software developed by the OpenSSL Project</span>
<a name="line-34"></a><span class="cm"> *    for use in the OpenSSL Toolkit (http://www.openssl.org/)&quot;</span>
<a name="line-35"></a><span class="cm"> *</span>
<a name="line-36"></a><span class="cm"> * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS&#39;&#39; AND ANY</span>
<a name="line-37"></a><span class="cm"> * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<a name="line-38"></a><span class="cm"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
<a name="line-39"></a><span class="cm"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR</span>
<a name="line-40"></a><span class="cm"> * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="line-41"></a><span class="cm"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<a name="line-42"></a><span class="cm"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<a name="line-43"></a><span class="cm"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<a name="line-44"></a><span class="cm"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<a name="line-45"></a><span class="cm"> * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a name="line-46"></a><span class="cm"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED</span>
<a name="line-47"></a><span class="cm"> * OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="line-48"></a><span class="cm"> * ====================================================================</span>
<a name="line-49"></a><span class="cm"> *</span>
<a name="line-50"></a><span class="cm"> * This product includes cryptographic software written by Eric Young</span>
<a name="line-51"></a><span class="cm"> * (eay@cryptsoft.com).  This product includes software written by Tim</span>
<a name="line-52"></a><span class="cm"> * Hudson (tjh@cryptsoft.com).</span>
<a name="line-53"></a><span class="cm"> *</span>
<a name="line-54"></a><span class="cm"> */</span>
<a name="line-55"></a>
<a name="line-56"></a><span class="cp">#include &quot;ssl_locl.h&quot;</span>
<a name="line-57"></a>
<a name="line-58"></a><span class="cp">#include &lt;openssl/md5.h&gt;</span>
<a name="line-59"></a><span class="cp">#include &lt;openssl/sha.h&gt;</span>
<a name="line-60"></a>
<a name="line-61"></a><span class="cm">/* MAX_HASH_BIT_COUNT_BYTES is the maximum number of bytes in the hash&#39;s length</span>
<a name="line-62"></a><span class="cm"> * field. (SHA-384/512 have 128-bit length.) */</span>
<a name="line-63"></a><span class="cp">#define MAX_HASH_BIT_COUNT_BYTES 16</span>
<a name="line-64"></a>
<a name="line-65"></a><span class="cm">/* MAX_HASH_BLOCK_SIZE is the maximum hash block size that we&#39;ll support.</span>
<a name="line-66"></a><span class="cm"> * Currently SHA-384/512 has a 128-byte block size and that&#39;s the largest</span>
<a name="line-67"></a><span class="cm"> * supported by TLS.) */</span>
<a name="line-68"></a><span class="cp">#define MAX_HASH_BLOCK_SIZE 128</span>
<a name="line-69"></a>
<a name="line-70"></a><span class="cm">/* Some utility functions are needed:</span>
<a name="line-71"></a><span class="cm"> *</span>
<a name="line-72"></a><span class="cm"> * These macros return the given value with the MSB copied to all the other</span>
<a name="line-73"></a><span class="cm"> * bits. They use the fact that arithmetic shift shifts-in the sign bit.</span>
<a name="line-74"></a><span class="cm"> * However, this is not ensured by the C standard so you may need to replace</span>
<a name="line-75"></a><span class="cm"> * them with something else on odd CPUs. */</span>
<a name="line-76"></a><span class="cp">#define DUPLICATE_MSB_TO_ALL(x) ( (unsigned)( (int)(x) &gt;&gt; (sizeof(int)*8-1) ) )</span>
<a name="line-77"></a><span class="cp">#define DUPLICATE_MSB_TO_ALL_8(x) ((unsigned char)(DUPLICATE_MSB_TO_ALL(x)))</span>
<a name="line-78"></a>
<a name="line-79"></a><span class="cm">/* constant_time_lt returns 0xff if a&lt;b and 0x00 otherwise. */</span>
<a name="line-80"></a><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">constant_time_lt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">a</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">b</span><span class="p">)</span>
<a name="line-81"></a>	<span class="p">{</span>
<a name="line-82"></a>	<span class="n">a</span> <span class="o">-=</span> <span class="n">b</span><span class="p">;</span>
<a name="line-83"></a>	<span class="k">return</span> <span class="n">DUPLICATE_MSB_TO_ALL</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<a name="line-84"></a>	<span class="p">}</span>
<a name="line-85"></a>
<a name="line-86"></a><span class="cm">/* constant_time_ge returns 0xff if a&gt;=b and 0x00 otherwise. */</span>
<a name="line-87"></a><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">constant_time_ge</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">a</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">b</span><span class="p">)</span>
<a name="line-88"></a>	<span class="p">{</span>
<a name="line-89"></a>	<span class="n">a</span> <span class="o">-=</span> <span class="n">b</span><span class="p">;</span>
<a name="line-90"></a>	<span class="k">return</span> <span class="n">DUPLICATE_MSB_TO_ALL</span><span class="p">(</span><span class="o">~</span><span class="n">a</span><span class="p">);</span>
<a name="line-91"></a>	<span class="p">}</span>
<a name="line-92"></a>
<a name="line-93"></a><span class="cm">/* constant_time_eq_8 returns 0xff if a==b and 0x00 otherwise. */</span>
<a name="line-94"></a><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">constant_time_eq_8</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">a</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">b</span><span class="p">)</span>
<a name="line-95"></a>	<span class="p">{</span>
<a name="line-96"></a>	<span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">;</span>
<a name="line-97"></a>	<span class="n">c</span><span class="o">--</span><span class="p">;</span>
<a name="line-98"></a>	<span class="k">return</span> <span class="n">DUPLICATE_MSB_TO_ALL_8</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<a name="line-99"></a>	<span class="p">}</span>
<a name="line-100"></a>
<a name="line-101"></a><span class="cm">/* ssl3_cbc_remove_padding removes padding from the decrypted, SSLv3, CBC</span>
<a name="line-102"></a><span class="cm"> * record in |rec| by updating |rec-&gt;length| in constant time.</span>
<a name="line-103"></a><span class="cm"> *</span>
<a name="line-104"></a><span class="cm"> * block_size: the block size of the cipher used to encrypt the record.</span>
<a name="line-105"></a><span class="cm"> * returns:</span>
<a name="line-106"></a><span class="cm"> *   0: (in non-constant time) if the record is publicly invalid.</span>
<a name="line-107"></a><span class="cm"> *   1: if the padding was valid</span>
<a name="line-108"></a><span class="cm"> *  -1: otherwise. */</span>
<a name="line-109"></a><span class="kt">int</span> <span class="nf">ssl3_cbc_remove_padding</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span>
<a name="line-110"></a>			    <span class="n">SSL3_RECORD</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span>
<a name="line-111"></a>			    <span class="kt">unsigned</span> <span class="n">block_size</span><span class="p">,</span>
<a name="line-112"></a>			    <span class="kt">unsigned</span> <span class="n">mac_size</span><span class="p">)</span>
<a name="line-113"></a>	<span class="p">{</span>
<a name="line-114"></a>	<span class="kt">unsigned</span> <span class="n">padding_length</span><span class="p">,</span> <span class="n">good</span><span class="p">;</span>
<a name="line-115"></a>	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">overhead</span> <span class="o">=</span> <span class="mi">1</span> <span class="cm">/* padding length byte */</span> <span class="o">+</span> <span class="n">mac_size</span><span class="p">;</span>
<a name="line-116"></a>
<a name="line-117"></a>	<span class="cm">/* These lengths are all public so we can test them in non-constant</span>
<a name="line-118"></a><span class="cm">	 * time. */</span>
<a name="line-119"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">overhead</span> <span class="o">&gt;</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
<a name="line-120"></a>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-121"></a>
<a name="line-122"></a>	<span class="n">padding_length</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<a name="line-123"></a>	<span class="n">good</span> <span class="o">=</span> <span class="n">constant_time_ge</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">padding_length</span><span class="o">+</span><span class="n">overhead</span><span class="p">);</span>
<a name="line-124"></a>	<span class="cm">/* SSLv3 requires that the padding is minimal. */</span>
<a name="line-125"></a>	<span class="n">good</span> <span class="o">&amp;=</span> <span class="n">constant_time_ge</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">padding_length</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<a name="line-126"></a>	<span class="n">padding_length</span> <span class="o">=</span> <span class="n">good</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">padding_length</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<a name="line-127"></a>	<span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-=</span> <span class="n">padding_length</span><span class="p">;</span>
<a name="line-128"></a>	<span class="n">rec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">|=</span> <span class="n">padding_length</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>	<span class="cm">/* kludge: pass padding length */</span>
<a name="line-129"></a>	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">good</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">good</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<a name="line-130"></a><span class="p">}</span>
<a name="line-131"></a>
<a name="line-132"></a><span class="cm">/* tls1_cbc_remove_padding removes the CBC padding from the decrypted, TLS, CBC</span>
<a name="line-133"></a><span class="cm"> * record in |rec| in constant time and returns 1 if the padding is valid and</span>
<a name="line-134"></a><span class="cm"> * -1 otherwise. It also removes any explicit IV from the start of the record</span>
<a name="line-135"></a><span class="cm"> * without leaking any timing about whether there was enough space after the</span>
<a name="line-136"></a><span class="cm"> * padding was removed.</span>
<a name="line-137"></a><span class="cm"> *</span>
<a name="line-138"></a><span class="cm"> * block_size: the block size of the cipher used to encrypt the record.</span>
<a name="line-139"></a><span class="cm"> * returns:</span>
<a name="line-140"></a><span class="cm"> *   0: (in non-constant time) if the record is publicly invalid.</span>
<a name="line-141"></a><span class="cm"> *   1: if the padding was valid</span>
<a name="line-142"></a><span class="cm"> *  -1: otherwise. */</span>
<a name="line-143"></a><span class="kt">int</span> <span class="nf">tls1_cbc_remove_padding</span><span class="p">(</span><span class="k">const</span> <span class="n">SSL</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span>
<a name="line-144"></a>			    <span class="n">SSL3_RECORD</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span>
<a name="line-145"></a>			    <span class="kt">unsigned</span> <span class="n">block_size</span><span class="p">,</span>
<a name="line-146"></a>			    <span class="kt">unsigned</span> <span class="n">mac_size</span><span class="p">)</span>
<a name="line-147"></a>	<span class="p">{</span>
<a name="line-148"></a>	<span class="kt">unsigned</span> <span class="n">padding_length</span><span class="p">,</span> <span class="n">good</span><span class="p">,</span> <span class="n">to_check</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
<a name="line-149"></a>	<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">overhead</span> <span class="o">=</span> <span class="mi">1</span> <span class="cm">/* padding length byte */</span> <span class="o">+</span> <span class="n">mac_size</span><span class="p">;</span>
<a name="line-150"></a>	<span class="cm">/* Check if version requires explicit IV */</span>
<a name="line-151"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="n">TLS1_1_VERSION</span> <span class="o">||</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">==</span> <span class="n">DTLS1_BAD_VER</span><span class="p">)</span>
<a name="line-152"></a>		<span class="p">{</span>
<a name="line-153"></a>		<span class="cm">/* These lengths are all public so we can test them in</span>
<a name="line-154"></a><span class="cm">		 * non-constant time.</span>
<a name="line-155"></a><span class="cm">		 */</span>
<a name="line-156"></a>		<span class="k">if</span> <span class="p">(</span><span class="n">overhead</span> <span class="o">+</span> <span class="n">block_size</span> <span class="o">&gt;</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
<a name="line-157"></a>			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-158"></a>		<span class="cm">/* We can now safely skip explicit IV */</span>
<a name="line-159"></a>		<span class="n">rec</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+=</span> <span class="n">block_size</span><span class="p">;</span>
<a name="line-160"></a>		<span class="n">rec</span><span class="o">-&gt;</span><span class="n">input</span> <span class="o">+=</span> <span class="n">block_size</span><span class="p">;</span>
<a name="line-161"></a>		<span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-=</span> <span class="n">block_size</span><span class="p">;</span>
<a name="line-162"></a>		<span class="p">}</span>
<a name="line-163"></a>	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">overhead</span> <span class="o">&gt;</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
<a name="line-164"></a>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-165"></a>
<a name="line-166"></a>	<span class="n">padding_length</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<a name="line-167"></a>
<a name="line-168"></a>	<span class="cm">/* NB: if compression is in operation the first packet may not be of</span>
<a name="line-169"></a><span class="cm">	 * even length so the padding bug check cannot be performed. This bug</span>
<a name="line-170"></a><span class="cm">	 * workaround has been around since SSLeay so hopefully it is either</span>
<a name="line-171"></a><span class="cm">	 * fixed now or no buggy implementation supports compression [steve]</span>
<a name="line-172"></a><span class="cm">	 */</span>
<a name="line-173"></a>	<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">options</span><span class="o">&amp;</span><span class="n">SSL_OP_TLS_BLOCK_PADDING_BUG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">expand</span><span class="p">)</span>
<a name="line-174"></a>		<span class="p">{</span>
<a name="line-175"></a>		<span class="cm">/* First packet is even in size, so check */</span>
<a name="line-176"></a>		<span class="k">if</span> <span class="p">((</span><span class="n">memcmp</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s3</span><span class="o">-&gt;</span><span class="n">read_sequence</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\0\0\0\0\0\0\0\0</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<a name="line-177"></a>		    <span class="o">!</span><span class="p">(</span><span class="n">padding_length</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
<a name="line-178"></a>			<span class="p">{</span>
<a name="line-179"></a>			<span class="n">s</span><span class="o">-&gt;</span><span class="n">s3</span><span class="o">-&gt;</span><span class="n">flags</span><span class="o">|=</span><span class="n">TLS1_FLAGS_TLS_PADDING_BUG</span><span class="p">;</span>
<a name="line-180"></a>			<span class="p">}</span>
<a name="line-181"></a>		<span class="k">if</span> <span class="p">((</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s3</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TLS1_FLAGS_TLS_PADDING_BUG</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
<a name="line-182"></a>		    <span class="n">padding_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-183"></a>			<span class="p">{</span>
<a name="line-184"></a>			<span class="n">padding_length</span><span class="o">--</span><span class="p">;</span>
<a name="line-185"></a>			<span class="p">}</span>
<a name="line-186"></a>		<span class="p">}</span>
<a name="line-187"></a>
<a name="line-188"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">EVP_CIPHER_flags</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">enc_read_ctx</span><span class="o">-&gt;</span><span class="n">cipher</span><span class="p">)</span><span class="o">&amp;</span><span class="n">EVP_CIPH_FLAG_AEAD_CIPHER</span><span class="p">)</span>
<a name="line-189"></a>		<span class="p">{</span>
<a name="line-190"></a>		<span class="cm">/* padding is already verified */</span>
<a name="line-191"></a>		<span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-=</span> <span class="n">padding_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-192"></a>		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-193"></a>		<span class="p">}</span>
<a name="line-194"></a>
<a name="line-195"></a>	<span class="n">good</span> <span class="o">=</span> <span class="n">constant_time_ge</span><span class="p">(</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="n">overhead</span><span class="o">+</span><span class="n">padding_length</span><span class="p">);</span>
<a name="line-196"></a>	<span class="cm">/* The padding consists of a length byte at the end of the record and</span>
<a name="line-197"></a><span class="cm">	 * then that many bytes of padding, all with the same value as the</span>
<a name="line-198"></a><span class="cm">	 * length byte. Thus, with the length byte included, there are i+1</span>
<a name="line-199"></a><span class="cm">	 * bytes of padding.</span>
<a name="line-200"></a><span class="cm">	 *</span>
<a name="line-201"></a><span class="cm">	 * We can&#39;t check just |padding_length+1| bytes because that leaks</span>
<a name="line-202"></a><span class="cm">	 * decrypted information. Therefore we always have to check the maximum</span>
<a name="line-203"></a><span class="cm">	 * amount of padding possible. (Again, the length of the record is</span>
<a name="line-204"></a><span class="cm">	 * public information so we can use it.) */</span>
<a name="line-205"></a>	<span class="n">to_check</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span> <span class="cm">/* maximum amount of padding. */</span>
<a name="line-206"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">to_check</span> <span class="o">&gt;</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<a name="line-207"></a>		<span class="n">to_check</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<a name="line-208"></a>
<a name="line-209"></a>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">to_check</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-210"></a>		<span class="p">{</span>
<a name="line-211"></a>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">constant_time_ge</span><span class="p">(</span><span class="n">padding_length</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<a name="line-212"></a>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">];</span>
<a name="line-213"></a>		<span class="cm">/* The final |padding_length+1| bytes should all have the value</span>
<a name="line-214"></a><span class="cm">		 * |padding_length|. Therefore the XOR should be zero. */</span>
<a name="line-215"></a>		<span class="n">good</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">mask</span><span class="o">&amp;</span><span class="p">(</span><span class="n">padding_length</span> <span class="o">^</span> <span class="n">b</span><span class="p">));</span>
<a name="line-216"></a>		<span class="p">}</span>
<a name="line-217"></a>
<a name="line-218"></a>	<span class="cm">/* If any of the final |padding_length+1| bytes had the wrong value,</span>
<a name="line-219"></a><span class="cm">	 * one or more of the lower eight bits of |good| will be cleared. We</span>
<a name="line-220"></a><span class="cm">	 * AND the bottom 8 bits together and duplicate the result to all the</span>
<a name="line-221"></a><span class="cm">	 * bits. */</span>
<a name="line-222"></a>	<span class="n">good</span> <span class="o">&amp;=</span> <span class="n">good</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
<a name="line-223"></a>	<span class="n">good</span> <span class="o">&amp;=</span> <span class="n">good</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
<a name="line-224"></a>	<span class="n">good</span> <span class="o">&amp;=</span> <span class="n">good</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-225"></a>	<span class="n">good</span> <span class="o">&lt;&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">good</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<a name="line-226"></a>	<span class="n">good</span> <span class="o">=</span> <span class="n">DUPLICATE_MSB_TO_ALL</span><span class="p">(</span><span class="n">good</span><span class="p">);</span>
<a name="line-227"></a>
<a name="line-228"></a>	<span class="n">padding_length</span> <span class="o">=</span> <span class="n">good</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">padding_length</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<a name="line-229"></a>	<span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-=</span> <span class="n">padding_length</span><span class="p">;</span>
<a name="line-230"></a>	<span class="n">rec</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">|=</span> <span class="n">padding_length</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>	<span class="cm">/* kludge: pass padding length */</span>
<a name="line-231"></a>
<a name="line-232"></a>	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">good</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">good</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<a name="line-233"></a>	<span class="p">}</span>
<a name="line-234"></a>
<a name="line-235"></a><span class="cm">/* ssl3_cbc_copy_mac copies |md_size| bytes from the end of |rec| to |out| in</span>
<a name="line-236"></a><span class="cm"> * constant time (independent of the concrete value of rec-&gt;length, which may</span>
<a name="line-237"></a><span class="cm"> * vary within a 256-byte window).</span>
<a name="line-238"></a><span class="cm"> *</span>
<a name="line-239"></a><span class="cm"> * ssl3_cbc_remove_padding or tls1_cbc_remove_padding must be called prior to</span>
<a name="line-240"></a><span class="cm"> * this function.</span>
<a name="line-241"></a><span class="cm"> *</span>
<a name="line-242"></a><span class="cm"> * On entry:</span>
<a name="line-243"></a><span class="cm"> *   rec-&gt;orig_len &gt;= md_size</span>
<a name="line-244"></a><span class="cm"> *   md_size &lt;= EVP_MAX_MD_SIZE</span>
<a name="line-245"></a><span class="cm"> *</span>
<a name="line-246"></a><span class="cm"> * If CBC_MAC_ROTATE_IN_PLACE is defined then the rotation is performed with</span>
<a name="line-247"></a><span class="cm"> * variable accesses in a 64-byte-aligned buffer. Assuming that this fits into</span>
<a name="line-248"></a><span class="cm"> * a single or pair of cache-lines, then the variable memory accesses don&#39;t</span>
<a name="line-249"></a><span class="cm"> * actually affect the timing. CPUs with smaller cache-lines [if any] are</span>
<a name="line-250"></a><span class="cm"> * not multi-core and are not considered vulnerable to cache-timing attacks.</span>
<a name="line-251"></a><span class="cm"> */</span>
<a name="line-252"></a><span class="cp">#define CBC_MAC_ROTATE_IN_PLACE</span>
<a name="line-253"></a>
<a name="line-254"></a><span class="kt">void</span> <span class="nf">ssl3_cbc_copy_mac</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">out</span><span class="p">,</span>
<a name="line-255"></a>		       <span class="k">const</span> <span class="n">SSL3_RECORD</span> <span class="o">*</span><span class="n">rec</span><span class="p">,</span>
<a name="line-256"></a>		       <span class="kt">unsigned</span> <span class="n">md_size</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">orig_len</span><span class="p">)</span>
<a name="line-257"></a>	<span class="p">{</span>
<a name="line-258"></a><span class="cp">#if defined(CBC_MAC_ROTATE_IN_PLACE)</span>
<a name="line-259"></a>	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rotated_mac_buf</span><span class="p">[</span><span class="mi">64</span><span class="o">+</span><span class="n">EVP_MAX_MD_SIZE</span><span class="p">];</span>
<a name="line-260"></a>	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rotated_mac</span><span class="p">;</span>
<a name="line-261"></a><span class="cp">#else</span>
<a name="line-262"></a>	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">rotated_mac</span><span class="p">[</span><span class="n">EVP_MAX_MD_SIZE</span><span class="p">];</span>
<a name="line-263"></a><span class="cp">#endif</span>
<a name="line-264"></a>
<a name="line-265"></a>	<span class="cm">/* mac_end is the index of |rec-&gt;data| just after the end of the MAC. */</span>
<a name="line-266"></a>	<span class="kt">unsigned</span> <span class="n">mac_end</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
<a name="line-267"></a>	<span class="kt">unsigned</span> <span class="n">mac_start</span> <span class="o">=</span> <span class="n">mac_end</span> <span class="o">-</span> <span class="n">md_size</span><span class="p">;</span>
<a name="line-268"></a>	<span class="cm">/* scan_start contains the number of bytes that we can ignore because</span>
<a name="line-269"></a><span class="cm">	 * the MAC&#39;s position can only vary by 255 bytes. */</span>
<a name="line-270"></a>	<span class="kt">unsigned</span> <span class="n">scan_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-271"></a>	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
<a name="line-272"></a>	<span class="kt">unsigned</span> <span class="n">div_spoiler</span><span class="p">;</span>
<a name="line-273"></a>	<span class="kt">unsigned</span> <span class="n">rotate_offset</span><span class="p">;</span>
<a name="line-274"></a>
<a name="line-275"></a>	<span class="n">OPENSSL_assert</span><span class="p">(</span><span class="n">orig_len</span> <span class="o">&gt;=</span> <span class="n">md_size</span><span class="p">);</span>
<a name="line-276"></a>	<span class="n">OPENSSL_assert</span><span class="p">(</span><span class="n">md_size</span> <span class="o">&lt;=</span> <span class="n">EVP_MAX_MD_SIZE</span><span class="p">);</span>
<a name="line-277"></a>
<a name="line-278"></a><span class="cp">#if defined(CBC_MAC_ROTATE_IN_PLACE)</span>
<a name="line-279"></a>	<span class="n">rotated_mac</span> <span class="o">=</span> <span class="n">rotated_mac_buf</span> <span class="o">+</span> <span class="p">((</span><span class="mi">0</span><span class="o">-</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">rotated_mac_buf</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">63</span><span class="p">);</span>
<a name="line-280"></a><span class="cp">#endif</span>
<a name="line-281"></a>
<a name="line-282"></a>	<span class="cm">/* This information is public so it&#39;s safe to branch based on it. */</span>
<a name="line-283"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">orig_len</span> <span class="o">&gt;</span> <span class="n">md_size</span> <span class="o">+</span> <span class="mi">255</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<a name="line-284"></a>		<span class="n">scan_start</span> <span class="o">=</span> <span class="n">orig_len</span> <span class="o">-</span> <span class="p">(</span><span class="n">md_size</span> <span class="o">+</span> <span class="mi">255</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<a name="line-285"></a>	<span class="cm">/* div_spoiler contains a multiple of md_size that is used to cause the</span>
<a name="line-286"></a><span class="cm">	 * modulo operation to be constant time. Without this, the time varies</span>
<a name="line-287"></a><span class="cm">	 * based on the amount of padding when running on Intel chips at least.</span>
<a name="line-288"></a><span class="cm">	 *</span>
<a name="line-289"></a><span class="cm">	 * The aim of right-shifting md_size is so that the compiler doesn&#39;t</span>
<a name="line-290"></a><span class="cm">	 * figure out that it can remove div_spoiler as that would require it</span>
<a name="line-291"></a><span class="cm">	 * to prove that md_size is always even, which I hope is beyond it. */</span>
<a name="line-292"></a>	<span class="n">div_spoiler</span> <span class="o">=</span> <span class="n">md_size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-293"></a>	<span class="n">div_spoiler</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">div_spoiler</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
<a name="line-294"></a>	<span class="n">rotate_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">div_spoiler</span> <span class="o">+</span> <span class="n">mac_start</span> <span class="o">-</span> <span class="n">scan_start</span><span class="p">)</span> <span class="o">%</span> <span class="n">md_size</span><span class="p">;</span>
<a name="line-295"></a>
<a name="line-296"></a>	<span class="n">memset</span><span class="p">(</span><span class="n">rotated_mac</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">md_size</span><span class="p">);</span>
<a name="line-297"></a>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">scan_start</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">orig_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-298"></a>		<span class="p">{</span>
<a name="line-299"></a>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mac_started</span> <span class="o">=</span> <span class="n">constant_time_ge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mac_start</span><span class="p">);</span>
<a name="line-300"></a>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mac_ended</span> <span class="o">=</span> <span class="n">constant_time_ge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mac_end</span><span class="p">);</span>
<a name="line-301"></a>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<a name="line-302"></a>		<span class="n">rotated_mac</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">|=</span> <span class="n">b</span> <span class="o">&amp;</span> <span class="n">mac_started</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mac_ended</span><span class="p">;</span>
<a name="line-303"></a>		<span class="n">j</span> <span class="o">&amp;=</span> <span class="n">constant_time_lt</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">md_size</span><span class="p">);</span>
<a name="line-304"></a>		<span class="p">}</span>
<a name="line-305"></a>
<a name="line-306"></a>	<span class="cm">/* Now rotate the MAC */</span>
<a name="line-307"></a><span class="cp">#if defined(CBC_MAC_ROTATE_IN_PLACE)</span>
<a name="line-308"></a>	<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-309"></a>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">md_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-310"></a>		<span class="p">{</span>
<a name="line-311"></a>		<span class="cm">/* in case cache-line is 32 bytes, touch second line */</span>
<a name="line-312"></a>		<span class="p">((</span><span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">rotated_mac</span><span class="p">)[</span><span class="n">rotate_offset</span><span class="o">^</span><span class="mi">32</span><span class="p">];</span>
<a name="line-313"></a>		<span class="n">out</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotated_mac</span><span class="p">[</span><span class="n">rotate_offset</span><span class="o">++</span><span class="p">];</span>
<a name="line-314"></a>		<span class="n">rotate_offset</span> <span class="o">&amp;=</span> <span class="n">constant_time_lt</span><span class="p">(</span><span class="n">rotate_offset</span><span class="p">,</span><span class="n">md_size</span><span class="p">);</span>
<a name="line-315"></a>		<span class="p">}</span>
<a name="line-316"></a><span class="cp">#else</span>
<a name="line-317"></a>	<span class="n">memset</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">md_size</span><span class="p">);</span>
<a name="line-318"></a>	<span class="n">rotate_offset</span> <span class="o">=</span> <span class="n">md_size</span> <span class="o">-</span> <span class="n">rotate_offset</span><span class="p">;</span>
<a name="line-319"></a>	<span class="n">rotate_offset</span> <span class="o">&amp;=</span> <span class="n">constant_time_lt</span><span class="p">(</span><span class="n">rotate_offset</span><span class="p">,</span><span class="n">md_size</span><span class="p">);</span>
<a name="line-320"></a>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">md_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-321"></a>		<span class="p">{</span>
<a name="line-322"></a>		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">md_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
<a name="line-323"></a>			<span class="n">out</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">rotated_mac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">constant_time_eq_8</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">rotate_offset</span><span class="p">);</span>
<a name="line-324"></a>		<span class="n">rotate_offset</span><span class="o">++</span><span class="p">;</span>
<a name="line-325"></a>		<span class="n">rotate_offset</span> <span class="o">&amp;=</span> <span class="n">constant_time_lt</span><span class="p">(</span><span class="n">rotate_offset</span><span class="p">,</span><span class="n">md_size</span><span class="p">);</span>
<a name="line-326"></a>		<span class="p">}</span>
<a name="line-327"></a><span class="cp">#endif</span>
<a name="line-328"></a>	<span class="p">}</span>
<a name="line-329"></a>
<a name="line-330"></a><span class="cm">/* u32toLE serialises an unsigned, 32-bit number (n) as four bytes at (p) in</span>
<a name="line-331"></a><span class="cm"> * little-endian order. The value of p is advanced by four. */</span>
<a name="line-332"></a><span class="cp">#define u32toLE(n, p) \</span>
<a name="line-333"></a><span class="cp">	(*((p)++)=(unsigned char)(n), \</span>
<a name="line-334"></a><span class="cp">	 *((p)++)=(unsigned char)(n&gt;&gt;8), \</span>
<a name="line-335"></a><span class="cp">	 *((p)++)=(unsigned char)(n&gt;&gt;16), \</span>
<a name="line-336"></a><span class="cp">	 *((p)++)=(unsigned char)(n&gt;&gt;24))</span>
<a name="line-337"></a>
<a name="line-338"></a><span class="cm">/* These functions serialize the state of a hash and thus perform the standard</span>
<a name="line-339"></a><span class="cm"> * &quot;final&quot; operation without adding the padding and length that such a function</span>
<a name="line-340"></a><span class="cm"> * typically does. */</span>
<a name="line-341"></a><span class="k">static</span> <span class="kt">void</span> <span class="nf">tls1_md5_final_raw</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">md_out</span><span class="p">)</span>
<a name="line-342"></a>	<span class="p">{</span>
<a name="line-343"></a>	<span class="n">MD5_CTX</span> <span class="o">*</span><span class="n">md5</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
<a name="line-344"></a>	<span class="n">u32toLE</span><span class="p">(</span><span class="n">md5</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">,</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-345"></a>	<span class="n">u32toLE</span><span class="p">(</span><span class="n">md5</span><span class="o">-&gt;</span><span class="n">B</span><span class="p">,</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-346"></a>	<span class="n">u32toLE</span><span class="p">(</span><span class="n">md5</span><span class="o">-&gt;</span><span class="n">C</span><span class="p">,</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-347"></a>	<span class="n">u32toLE</span><span class="p">(</span><span class="n">md5</span><span class="o">-&gt;</span><span class="n">D</span><span class="p">,</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-348"></a>	<span class="p">}</span>
<a name="line-349"></a>
<a name="line-350"></a><span class="k">static</span> <span class="kt">void</span> <span class="nf">tls1_sha1_final_raw</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">md_out</span><span class="p">)</span>
<a name="line-351"></a>	<span class="p">{</span>
<a name="line-352"></a>	<span class="n">SHA_CTX</span> <span class="o">*</span><span class="n">sha1</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
<a name="line-353"></a>	<span class="n">l2n</span><span class="p">(</span><span class="n">sha1</span><span class="o">-&gt;</span><span class="n">h0</span><span class="p">,</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-354"></a>	<span class="n">l2n</span><span class="p">(</span><span class="n">sha1</span><span class="o">-&gt;</span><span class="n">h1</span><span class="p">,</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-355"></a>	<span class="n">l2n</span><span class="p">(</span><span class="n">sha1</span><span class="o">-&gt;</span><span class="n">h2</span><span class="p">,</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-356"></a>	<span class="n">l2n</span><span class="p">(</span><span class="n">sha1</span><span class="o">-&gt;</span><span class="n">h3</span><span class="p">,</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-357"></a>	<span class="n">l2n</span><span class="p">(</span><span class="n">sha1</span><span class="o">-&gt;</span><span class="n">h4</span><span class="p">,</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-358"></a>	<span class="p">}</span>
<a name="line-359"></a><span class="cp">#define LARGEST_DIGEST_CTX SHA_CTX</span>
<a name="line-360"></a>
<a name="line-361"></a><span class="cp">#ifndef OPENSSL_NO_SHA256</span>
<a name="line-362"></a><span class="k">static</span> <span class="kt">void</span> <span class="nf">tls1_sha256_final_raw</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">md_out</span><span class="p">)</span>
<a name="line-363"></a>	<span class="p">{</span>
<a name="line-364"></a>	<span class="n">SHA256_CTX</span> <span class="o">*</span><span class="n">sha256</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
<a name="line-365"></a>	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
<a name="line-366"></a>
<a name="line-367"></a>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-368"></a>		<span class="p">{</span>
<a name="line-369"></a>		<span class="n">l2n</span><span class="p">(</span><span class="n">sha256</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-370"></a>		<span class="p">}</span>
<a name="line-371"></a>	<span class="p">}</span>
<a name="line-372"></a><span class="cp">#undef  LARGEST_DIGEST_CTX</span>
<a name="line-373"></a><span class="cp">#define LARGEST_DIGEST_CTX SHA256_CTX</span>
<a name="line-374"></a><span class="cp">#endif</span>
<a name="line-375"></a>
<a name="line-376"></a><span class="cp">#ifndef OPENSSL_NO_SHA512</span>
<a name="line-377"></a><span class="k">static</span> <span class="kt">void</span> <span class="nf">tls1_sha512_final_raw</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">md_out</span><span class="p">)</span>
<a name="line-378"></a>	<span class="p">{</span>
<a name="line-379"></a>	<span class="n">SHA512_CTX</span> <span class="o">*</span><span class="n">sha512</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
<a name="line-380"></a>	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
<a name="line-381"></a>
<a name="line-382"></a>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-383"></a>		<span class="p">{</span>
<a name="line-384"></a>		<span class="n">l2n8</span><span class="p">(</span><span class="n">sha512</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">md_out</span><span class="p">);</span>
<a name="line-385"></a>		<span class="p">}</span>
<a name="line-386"></a>	<span class="p">}</span>
<a name="line-387"></a><span class="cp">#undef  LARGEST_DIGEST_CTX</span>
<a name="line-388"></a><span class="cp">#define LARGEST_DIGEST_CTX SHA512_CTX</span>
<a name="line-389"></a><span class="cp">#endif</span>
<a name="line-390"></a>
<a name="line-391"></a><span class="cm">/* ssl3_cbc_record_digest_supported returns 1 iff |ctx| uses a hash function</span>
<a name="line-392"></a><span class="cm"> * which ssl3_cbc_digest_record supports. */</span>
<a name="line-393"></a><span class="kt">char</span> <span class="nf">ssl3_cbc_record_digest_supported</span><span class="p">(</span><span class="k">const</span> <span class="n">EVP_MD_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<a name="line-394"></a>	<span class="p">{</span>
<a name="line-395"></a><span class="cp">#ifdef OPENSSL_FIPS</span>
<a name="line-396"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">FIPS_mode</span><span class="p">())</span>
<a name="line-397"></a>		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-398"></a><span class="cp">#endif</span>
<a name="line-399"></a>	<span class="k">switch</span> <span class="p">(</span><span class="n">EVP_MD_CTX_type</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
<a name="line-400"></a>		<span class="p">{</span>
<a name="line-401"></a>		<span class="k">case</span> <span class="nl">NID_md5</span><span class="p">:</span>
<a name="line-402"></a>		<span class="k">case</span> <span class="nl">NID_sha1</span><span class="p">:</span>
<a name="line-403"></a><span class="cp">#ifndef OPENSSL_NO_SHA256</span>
<a name="line-404"></a>		<span class="k">case</span> <span class="nl">NID_sha224</span><span class="p">:</span>
<a name="line-405"></a>		<span class="k">case</span> <span class="nl">NID_sha256</span><span class="p">:</span>
<a name="line-406"></a><span class="cp">#endif</span>
<a name="line-407"></a><span class="cp">#ifndef OPENSSL_NO_SHA512</span>
<a name="line-408"></a>		<span class="k">case</span> <span class="nl">NID_sha384</span><span class="p">:</span>
<a name="line-409"></a>		<span class="k">case</span> <span class="nl">NID_sha512</span><span class="p">:</span>
<a name="line-410"></a><span class="cp">#endif</span>
<a name="line-411"></a>			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-412"></a>		<span class="k">default</span><span class="o">:</span>
<a name="line-413"></a>			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-414"></a>		<span class="p">}</span>
<a name="line-415"></a>	<span class="p">}</span>
<a name="line-416"></a>
<a name="line-417"></a><span class="cm">/* ssl3_cbc_digest_record computes the MAC of a decrypted, padded SSLv3/TLS</span>
<a name="line-418"></a><span class="cm"> * record.</span>
<a name="line-419"></a><span class="cm"> *</span>
<a name="line-420"></a><span class="cm"> *   ctx: the EVP_MD_CTX from which we take the hash function.</span>
<a name="line-421"></a><span class="cm"> *     ssl3_cbc_record_digest_supported must return true for this EVP_MD_CTX.</span>
<a name="line-422"></a><span class="cm"> *   md_out: the digest output. At most EVP_MAX_MD_SIZE bytes will be written.</span>
<a name="line-423"></a><span class="cm"> *   md_out_size: if non-NULL, the number of output bytes is written here.</span>
<a name="line-424"></a><span class="cm"> *   header: the 13-byte, TLS record header.</span>
<a name="line-425"></a><span class="cm"> *   data: the record data itself, less any preceeding explicit IV.</span>
<a name="line-426"></a><span class="cm"> *   data_plus_mac_size: the secret, reported length of the data and MAC</span>
<a name="line-427"></a><span class="cm"> *     once the padding has been removed.</span>
<a name="line-428"></a><span class="cm"> *   data_plus_mac_plus_padding_size: the public length of the whole</span>
<a name="line-429"></a><span class="cm"> *     record, including padding.</span>
<a name="line-430"></a><span class="cm"> *   is_sslv3: non-zero if we are to use SSLv3. Otherwise, TLS.</span>
<a name="line-431"></a><span class="cm"> *</span>
<a name="line-432"></a><span class="cm"> * On entry: by virtue of having been through one of the remove_padding</span>
<a name="line-433"></a><span class="cm"> * functions, above, we know that data_plus_mac_size is large enough to contain</span>
<a name="line-434"></a><span class="cm"> * a padding byte and MAC. (If the padding was invalid, it might contain the</span>
<a name="line-435"></a><span class="cm"> * padding too. ) */</span>
<a name="line-436"></a><span class="kt">void</span> <span class="nf">ssl3_cbc_digest_record</span><span class="p">(</span>
<a name="line-437"></a>	<span class="k">const</span> <span class="n">EVP_MD_CTX</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
<a name="line-438"></a>	<span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">md_out</span><span class="p">,</span>
<a name="line-439"></a>	<span class="kt">size_t</span><span class="o">*</span> <span class="n">md_out_size</span><span class="p">,</span>
<a name="line-440"></a>	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">header</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span>
<a name="line-441"></a>	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
<a name="line-442"></a>	<span class="kt">size_t</span> <span class="n">data_plus_mac_size</span><span class="p">,</span>
<a name="line-443"></a>	<span class="kt">size_t</span> <span class="n">data_plus_mac_plus_padding_size</span><span class="p">,</span>
<a name="line-444"></a>	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mac_secret</span><span class="p">,</span>
<a name="line-445"></a>	<span class="kt">unsigned</span> <span class="n">mac_secret_length</span><span class="p">,</span>
<a name="line-446"></a>	<span class="kt">char</span> <span class="n">is_sslv3</span><span class="p">)</span>
<a name="line-447"></a>	<span class="p">{</span>
<a name="line-448"></a>	<span class="k">union</span> <span class="p">{</span>	<span class="kt">double</span> <span class="n">align</span><span class="p">;</span>
<a name="line-449"></a>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LARGEST_DIGEST_CTX</span><span class="p">)];</span> <span class="p">}</span> <span class="n">md_state</span><span class="p">;</span>
<a name="line-450"></a>	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">md_final_raw</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">md_out</span><span class="p">);</span>
<a name="line-451"></a>	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">md_transform</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">block</span><span class="p">);</span>
<a name="line-452"></a>	<span class="kt">unsigned</span> <span class="n">md_size</span><span class="p">,</span> <span class="n">md_block_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<a name="line-453"></a>	<span class="kt">unsigned</span> <span class="n">sslv3_pad_length</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">header_length</span><span class="p">,</span> <span class="n">variance_blocks</span><span class="p">,</span>
<a name="line-454"></a>		 <span class="n">len</span><span class="p">,</span> <span class="n">max_mac_bytes</span><span class="p">,</span> <span class="n">num_blocks</span><span class="p">,</span>
<a name="line-455"></a>		 <span class="n">num_starting_blocks</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mac_end_offset</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">index_a</span><span class="p">,</span> <span class="n">index_b</span><span class="p">;</span>
<a name="line-456"></a>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">;</span>	<span class="cm">/* at most 18 bits */</span>
<a name="line-457"></a>	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">length_bytes</span><span class="p">[</span><span class="n">MAX_HASH_BIT_COUNT_BYTES</span><span class="p">];</span>
<a name="line-458"></a>	<span class="cm">/* hmac_pad is the masked HMAC key. */</span>
<a name="line-459"></a>	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">hmac_pad</span><span class="p">[</span><span class="n">MAX_HASH_BLOCK_SIZE</span><span class="p">];</span>
<a name="line-460"></a><span class="hll">	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">first_block</span><span class="p">[</span><span class="n">MAX_HASH_BLOCK_SIZE</span><span class="p">];</span><div class='verbose expandable'><span class='error2'>&lt;--- The scope of the variable 'first_block' can be reduced. <span class='marker'>[+]</span></span><div class='content'>The scope of the variable &apos;first_block&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:
void f(int x)
{
    int i = 0;
    if (x) {
        // it&apos;s safe to move &apos;int i = 0;&apos; here
        for (int n = 0; n &lt; 10; ++n) {
            // it is possible but not safe to move &apos;int i = 0;&apos; here
            do_something(&amp;i);
        }
    }
}
When you see this message it is always safe to reduce the variable scope 1 level.</div></div>
</span><a name="line-461"></a>	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mac_out</span><span class="p">[</span><span class="n">EVP_MAX_MD_SIZE</span><span class="p">];</span>
<a name="line-462"></a>	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">md_out_size_u</span><span class="p">;</span>
<a name="line-463"></a>	<span class="n">EVP_MD_CTX</span> <span class="n">md_ctx</span><span class="p">;</span>
<a name="line-464"></a>	<span class="cm">/* mdLengthSize is the number of bytes in the length field that terminates</span>
<a name="line-465"></a><span class="cm">	* the hash. */</span>
<a name="line-466"></a>	<span class="kt">unsigned</span> <span class="n">md_length_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<a name="line-467"></a>	<span class="kt">char</span> <span class="n">length_is_big_endian</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-468"></a>
<a name="line-469"></a>	<span class="cm">/* This is a, hopefully redundant, check that allows us to forget about</span>
<a name="line-470"></a><span class="cm">	 * many possible overflows later in this function. */</span>
<a name="line-471"></a>	<span class="n">OPENSSL_assert</span><span class="p">(</span><span class="n">data_plus_mac_plus_padding_size</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>
<a name="line-472"></a>
<a name="line-473"></a>	<span class="k">switch</span> <span class="p">(</span><span class="n">EVP_MD_CTX_type</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>
<a name="line-474"></a>		<span class="p">{</span>
<a name="line-475"></a>		<span class="k">case</span> <span class="nl">NID_md5</span><span class="p">:</span>
<a name="line-476"></a>			<span class="n">MD5_Init</span><span class="p">((</span><span class="n">MD5_CTX</span><span class="o">*</span><span class="p">)</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
<a name="line-477"></a>			<span class="n">md_final_raw</span> <span class="o">=</span> <span class="n">tls1_md5_final_raw</span><span class="p">;</span>
<a name="line-478"></a>			<span class="n">md_transform</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">block</span><span class="p">))</span> <span class="n">MD5_Transform</span><span class="p">;</span>
<a name="line-479"></a>			<span class="n">md_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<a name="line-480"></a>			<span class="n">sslv3_pad_length</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
<a name="line-481"></a>			<span class="n">length_is_big_endian</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-482"></a>			<span class="k">break</span><span class="p">;</span>
<a name="line-483"></a>		<span class="k">case</span> <span class="nl">NID_sha1</span><span class="p">:</span>
<a name="line-484"></a>			<span class="n">SHA1_Init</span><span class="p">((</span><span class="n">SHA_CTX</span><span class="o">*</span><span class="p">)</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
<a name="line-485"></a>			<span class="n">md_final_raw</span> <span class="o">=</span> <span class="n">tls1_sha1_final_raw</span><span class="p">;</span>
<a name="line-486"></a>			<span class="n">md_transform</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">block</span><span class="p">))</span> <span class="n">SHA1_Transform</span><span class="p">;</span>
<a name="line-487"></a>			<span class="n">md_size</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<a name="line-488"></a>			<span class="k">break</span><span class="p">;</span>
<a name="line-489"></a><span class="cp">#ifndef OPENSSL_NO_SHA256</span>
<a name="line-490"></a>		<span class="k">case</span> <span class="nl">NID_sha224</span><span class="p">:</span>
<a name="line-491"></a>			<span class="n">SHA224_Init</span><span class="p">((</span><span class="n">SHA256_CTX</span><span class="o">*</span><span class="p">)</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
<a name="line-492"></a>			<span class="n">md_final_raw</span> <span class="o">=</span> <span class="n">tls1_sha256_final_raw</span><span class="p">;</span>
<a name="line-493"></a>			<span class="n">md_transform</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">block</span><span class="p">))</span> <span class="n">SHA256_Transform</span><span class="p">;</span>
<a name="line-494"></a>			<span class="n">md_size</span> <span class="o">=</span> <span class="mi">224</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span>
<a name="line-495"></a>			<span class="k">break</span><span class="p">;</span>
<a name="line-496"></a>		<span class="k">case</span> <span class="nl">NID_sha256</span><span class="p">:</span>
<a name="line-497"></a>			<span class="n">SHA256_Init</span><span class="p">((</span><span class="n">SHA256_CTX</span><span class="o">*</span><span class="p">)</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
<a name="line-498"></a>			<span class="n">md_final_raw</span> <span class="o">=</span> <span class="n">tls1_sha256_final_raw</span><span class="p">;</span>
<a name="line-499"></a>			<span class="n">md_transform</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">block</span><span class="p">))</span> <span class="n">SHA256_Transform</span><span class="p">;</span>
<a name="line-500"></a>			<span class="n">md_size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<a name="line-501"></a>			<span class="k">break</span><span class="p">;</span>
<a name="line-502"></a><span class="cp">#endif</span>
<a name="line-503"></a><span class="cp">#ifndef OPENSSL_NO_SHA512</span>
<a name="line-504"></a>		<span class="k">case</span> <span class="nl">NID_sha384</span><span class="p">:</span>
<a name="line-505"></a>			<span class="n">SHA384_Init</span><span class="p">((</span><span class="n">SHA512_CTX</span><span class="o">*</span><span class="p">)</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
<a name="line-506"></a>			<span class="n">md_final_raw</span> <span class="o">=</span> <span class="n">tls1_sha512_final_raw</span><span class="p">;</span>
<a name="line-507"></a>			<span class="n">md_transform</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">block</span><span class="p">))</span> <span class="n">SHA512_Transform</span><span class="p">;</span>
<a name="line-508"></a>			<span class="n">md_size</span> <span class="o">=</span> <span class="mi">384</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span>
<a name="line-509"></a>			<span class="n">md_block_size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
<a name="line-510"></a>			<span class="n">md_length_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<a name="line-511"></a>			<span class="k">break</span><span class="p">;</span>
<a name="line-512"></a>		<span class="k">case</span> <span class="nl">NID_sha512</span><span class="p">:</span>
<a name="line-513"></a>			<span class="n">SHA512_Init</span><span class="p">((</span><span class="n">SHA512_CTX</span><span class="o">*</span><span class="p">)</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">);</span>
<a name="line-514"></a>			<span class="n">md_final_raw</span> <span class="o">=</span> <span class="n">tls1_sha512_final_raw</span><span class="p">;</span>
<a name="line-515"></a>			<span class="n">md_transform</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">block</span><span class="p">))</span> <span class="n">SHA512_Transform</span><span class="p">;</span>
<a name="line-516"></a>			<span class="n">md_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
<a name="line-517"></a>			<span class="n">md_block_size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
<a name="line-518"></a>			<span class="n">md_length_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<a name="line-519"></a>			<span class="k">break</span><span class="p">;</span>
<a name="line-520"></a><span class="cp">#endif</span>
<a name="line-521"></a>		<span class="k">default</span><span class="o">:</span>
<a name="line-522"></a>			<span class="cm">/* ssl3_cbc_record_digest_supported should have been</span>
<a name="line-523"></a><span class="cm">			 * called first to check that the hash function is</span>
<a name="line-524"></a><span class="cm">			 * supported. */</span>
<a name="line-525"></a>			<span class="n">OPENSSL_assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<a name="line-526"></a>			<span class="k">if</span> <span class="p">(</span><span class="n">md_out_size</span><span class="p">)</span>
<a name="line-527"></a>				<span class="o">*</span><span class="n">md_out_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<a name="line-528"></a>			<span class="k">return</span><span class="p">;</span>
<a name="line-529"></a>		<span class="p">}</span>
<a name="line-530"></a>
<a name="line-531"></a>	<span class="n">OPENSSL_assert</span><span class="p">(</span><span class="n">md_length_size</span> <span class="o">&lt;=</span> <span class="n">MAX_HASH_BIT_COUNT_BYTES</span><span class="p">);</span>
<a name="line-532"></a>	<span class="n">OPENSSL_assert</span><span class="p">(</span><span class="n">md_block_size</span> <span class="o">&lt;=</span> <span class="n">MAX_HASH_BLOCK_SIZE</span><span class="p">);</span>
<a name="line-533"></a>	<span class="n">OPENSSL_assert</span><span class="p">(</span><span class="n">md_size</span> <span class="o">&lt;=</span> <span class="n">EVP_MAX_MD_SIZE</span><span class="p">);</span>
<a name="line-534"></a>
<a name="line-535"></a>	<span class="n">header_length</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
<a name="line-536"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">is_sslv3</span><span class="p">)</span>
<a name="line-537"></a>		<span class="p">{</span>
<a name="line-538"></a>		<span class="n">header_length</span> <span class="o">=</span>
<a name="line-539"></a>			<span class="n">mac_secret_length</span> <span class="o">+</span>
<a name="line-540"></a>			<span class="n">sslv3_pad_length</span> <span class="o">+</span>
<a name="line-541"></a>			<span class="mi">8</span> <span class="cm">/* sequence number */</span> <span class="o">+</span>
<a name="line-542"></a>			<span class="mi">1</span> <span class="cm">/* record type */</span> <span class="o">+</span>
<a name="line-543"></a>			<span class="mi">2</span> <span class="cm">/* record length */</span><span class="p">;</span>
<a name="line-544"></a>		<span class="p">}</span>
<a name="line-545"></a>
<a name="line-546"></a>	<span class="cm">/* variance_blocks is the number of blocks of the hash that we have to</span>
<a name="line-547"></a><span class="cm">	 * calculate in constant time because they could be altered by the</span>
<a name="line-548"></a><span class="cm">	 * padding value.</span>
<a name="line-549"></a><span class="cm">	 *</span>
<a name="line-550"></a><span class="cm">	 * In SSLv3, the padding must be minimal so the end of the plaintext</span>
<a name="line-551"></a><span class="cm">	 * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that</span>
<a name="line-552"></a><span class="cm">	 * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash</span>
<a name="line-553"></a><span class="cm">	 * termination (0x80 + 64-bit length) don&#39;t fit in the final block, we</span>
<a name="line-554"></a><span class="cm">	 * say that the final two blocks can vary based on the padding.</span>
<a name="line-555"></a><span class="cm">	 *</span>
<a name="line-556"></a><span class="cm">	 * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not</span>
<a name="line-557"></a><span class="cm">	 * required to be minimal. Therefore we say that the final six blocks</span>
<a name="line-558"></a><span class="cm">	 * can vary based on the padding.</span>
<a name="line-559"></a><span class="cm">	 *</span>
<a name="line-560"></a><span class="cm">	 * Later in the function, if the message is short and there obviously</span>
<a name="line-561"></a><span class="cm">	 * cannot be this many blocks then variance_blocks can be reduced. */</span>
<a name="line-562"></a>	<span class="n">variance_blocks</span> <span class="o">=</span> <span class="n">is_sslv3</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">6</span><span class="p">;</span>
<a name="line-563"></a>	<span class="cm">/* From now on we&#39;re dealing with the MAC, which conceptually has 13</span>
<a name="line-564"></a><span class="cm">	 * bytes of `header&#39; before the start of the data (TLS) or 71/75 bytes</span>
<a name="line-565"></a><span class="cm">	 * (SSLv3) */</span>
<a name="line-566"></a>	<span class="n">len</span> <span class="o">=</span> <span class="n">data_plus_mac_plus_padding_size</span> <span class="o">+</span> <span class="n">header_length</span><span class="p">;</span>
<a name="line-567"></a>	<span class="cm">/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including</span>
<a name="line-568"></a><span class="cm">	* |header|, assuming that there&#39;s no padding. */</span>
<a name="line-569"></a>	<span class="n">max_mac_bytes</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">md_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<a name="line-570"></a>	<span class="cm">/* num_blocks is the maximum number of hash blocks. */</span>
<a name="line-571"></a>	<span class="n">num_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_mac_bytes</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">md_length_size</span> <span class="o">+</span> <span class="n">md_block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">md_block_size</span><span class="p">;</span>
<a name="line-572"></a>	<span class="cm">/* In order to calculate the MAC in constant time we have to handle</span>
<a name="line-573"></a><span class="cm">	 * the final blocks specially because the padding value could cause the</span>
<a name="line-574"></a><span class="cm">	 * end to appear somewhere in the final |variance_blocks| blocks and we</span>
<a name="line-575"></a><span class="cm">	 * can&#39;t leak where. However, |num_starting_blocks| worth of data can</span>
<a name="line-576"></a><span class="cm">	 * be hashed right away because no padding value can affect whether</span>
<a name="line-577"></a><span class="cm">	 * they are plaintext. */</span>
<a name="line-578"></a>	<span class="n">num_starting_blocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-579"></a>	<span class="cm">/* k is the starting byte offset into the conceptual header||data where</span>
<a name="line-580"></a><span class="cm">	 * we start processing. */</span>
<a name="line-581"></a>	<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<a name="line-582"></a>	<span class="cm">/* mac_end_offset is the index just past the end of the data to be</span>
<a name="line-583"></a><span class="cm">	 * MACed. */</span>
<a name="line-584"></a>	<span class="n">mac_end_offset</span> <span class="o">=</span> <span class="n">data_plus_mac_size</span> <span class="o">+</span> <span class="n">header_length</span> <span class="o">-</span> <span class="n">md_size</span><span class="p">;</span>
<a name="line-585"></a>	<span class="cm">/* c is the index of the 0x80 byte in the final hash block that</span>
<a name="line-586"></a><span class="cm">	 * contains application data. */</span>
<a name="line-587"></a>	<span class="n">c</span> <span class="o">=</span> <span class="n">mac_end_offset</span> <span class="o">%</span> <span class="n">md_block_size</span><span class="p">;</span>
<a name="line-588"></a>	<span class="cm">/* index_a is the hash block number that contains the 0x80 terminating</span>
<a name="line-589"></a><span class="cm">	 * value. */</span>
<a name="line-590"></a>	<span class="n">index_a</span> <span class="o">=</span> <span class="n">mac_end_offset</span> <span class="o">/</span> <span class="n">md_block_size</span><span class="p">;</span>
<a name="line-591"></a>	<span class="cm">/* index_b is the hash block number that contains the 64-bit hash</span>
<a name="line-592"></a><span class="cm">	 * length, in bits. */</span>
<a name="line-593"></a>	<span class="n">index_b</span> <span class="o">=</span> <span class="p">(</span><span class="n">mac_end_offset</span> <span class="o">+</span> <span class="n">md_length_size</span><span class="p">)</span> <span class="o">/</span> <span class="n">md_block_size</span><span class="p">;</span>
<a name="line-594"></a>	<span class="cm">/* bits is the hash-length in bits. It includes the additional hash</span>
<a name="line-595"></a><span class="cm">	 * block for the masked HMAC key, or whole of |header| in the case of</span>
<a name="line-596"></a><span class="cm">	 * SSLv3. */</span>
<a name="line-597"></a>
<a name="line-598"></a>	<span class="cm">/* For SSLv3, if we&#39;re going to have any starting blocks then we need</span>
<a name="line-599"></a><span class="cm">	 * at least two because the header is larger than a single block. */</span>
<a name="line-600"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">num_blocks</span> <span class="o">&gt;</span> <span class="n">variance_blocks</span> <span class="o">+</span> <span class="p">(</span><span class="n">is_sslv3</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">))</span>
<a name="line-601"></a>		<span class="p">{</span>
<a name="line-602"></a>		<span class="n">num_starting_blocks</span> <span class="o">=</span> <span class="n">num_blocks</span> <span class="o">-</span> <span class="n">variance_blocks</span><span class="p">;</span>
<a name="line-603"></a>		<span class="n">k</span> <span class="o">=</span> <span class="n">md_block_size</span><span class="o">*</span><span class="n">num_starting_blocks</span><span class="p">;</span>
<a name="line-604"></a>		<span class="p">}</span>
<a name="line-605"></a>
<a name="line-606"></a>	<span class="n">bits</span> <span class="o">=</span> <span class="mi">8</span><span class="o">*</span><span class="n">mac_end_offset</span><span class="p">;</span>
<a name="line-607"></a>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_sslv3</span><span class="p">)</span>
<a name="line-608"></a>		<span class="p">{</span>
<a name="line-609"></a>		<span class="cm">/* Compute the initial HMAC block. For SSLv3, the padding and</span>
<a name="line-610"></a><span class="cm">		 * secret bytes are included in |header| because they take more</span>
<a name="line-611"></a><span class="cm">		 * than a single block. */</span>
<a name="line-612"></a>		<span class="n">bits</span> <span class="o">+=</span> <span class="mi">8</span><span class="o">*</span><span class="n">md_block_size</span><span class="p">;</span>
<a name="line-613"></a>		<span class="n">memset</span><span class="p">(</span><span class="n">hmac_pad</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">md_block_size</span><span class="p">);</span>
<a name="line-614"></a>		<span class="n">OPENSSL_assert</span><span class="p">(</span><span class="n">mac_secret_length</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hmac_pad</span><span class="p">));</span>
<a name="line-615"></a>		<span class="n">memcpy</span><span class="p">(</span><span class="n">hmac_pad</span><span class="p">,</span> <span class="n">mac_secret</span><span class="p">,</span> <span class="n">mac_secret_length</span><span class="p">);</span>
<a name="line-616"></a>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">md_block_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-617"></a>			<span class="n">hmac_pad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="mh">0x36</span><span class="p">;</span>
<a name="line-618"></a>
<a name="line-619"></a>		<span class="n">md_transform</span><span class="p">(</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">hmac_pad</span><span class="p">);</span>
<a name="line-620"></a>		<span class="p">}</span>
<a name="line-621"></a>
<a name="line-622"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">length_is_big_endian</span><span class="p">)</span>
<a name="line-623"></a>		<span class="p">{</span>
<a name="line-624"></a>		<span class="n">memset</span><span class="p">(</span><span class="n">length_bytes</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">md_length_size</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
<a name="line-625"></a>		<span class="n">length_bytes</span><span class="p">[</span><span class="n">md_length_size</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">bits</span><span class="o">&gt;&gt;</span><span class="mi">24</span><span class="p">);</span>
<a name="line-626"></a>		<span class="n">length_bytes</span><span class="p">[</span><span class="n">md_length_size</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">bits</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
<a name="line-627"></a>		<span class="n">length_bytes</span><span class="p">[</span><span class="n">md_length_size</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">bits</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span>
<a name="line-628"></a>		<span class="n">length_bytes</span><span class="p">[</span><span class="n">md_length_size</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">bits</span><span class="p">;</span>
<a name="line-629"></a>		<span class="p">}</span>
<a name="line-630"></a>	<span class="k">else</span>
<a name="line-631"></a>		<span class="p">{</span>
<a name="line-632"></a>		<span class="n">memset</span><span class="p">(</span><span class="n">length_bytes</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">md_length_size</span><span class="p">);</span>
<a name="line-633"></a>		<span class="n">length_bytes</span><span class="p">[</span><span class="n">md_length_size</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">bits</span><span class="o">&gt;&gt;</span><span class="mi">24</span><span class="p">);</span>
<a name="line-634"></a>		<span class="n">length_bytes</span><span class="p">[</span><span class="n">md_length_size</span><span class="o">-</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">bits</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
<a name="line-635"></a>		<span class="n">length_bytes</span><span class="p">[</span><span class="n">md_length_size</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">bits</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span>
<a name="line-636"></a>		<span class="n">length_bytes</span><span class="p">[</span><span class="n">md_length_size</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">bits</span><span class="p">;</span>
<a name="line-637"></a>		<span class="p">}</span>
<a name="line-638"></a>
<a name="line-639"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<a name="line-640"></a>		<span class="p">{</span>
<a name="line-641"></a>		<span class="k">if</span> <span class="p">(</span><span class="n">is_sslv3</span><span class="p">)</span>
<a name="line-642"></a>			<span class="p">{</span>
<a name="line-643"></a>			<span class="cm">/* The SSLv3 header is larger than a single block.</span>
<a name="line-644"></a><span class="cm">			 * overhang is the number of bytes beyond a single</span>
<a name="line-645"></a><span class="cm">			 * block that the header consumes: either 7 bytes</span>
<a name="line-646"></a><span class="cm">			 * (SHA1) or 11 bytes (MD5). */</span>
<a name="line-647"></a>			<span class="kt">unsigned</span> <span class="n">overhang</span> <span class="o">=</span> <span class="n">header_length</span><span class="o">-</span><span class="n">md_block_size</span><span class="p">;</span>
<a name="line-648"></a>			<span class="n">md_transform</span><span class="p">(</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">header</span><span class="p">);</span>
<a name="line-649"></a>			<span class="n">memcpy</span><span class="p">(</span><span class="n">first_block</span><span class="p">,</span> <span class="n">header</span> <span class="o">+</span> <span class="n">md_block_size</span><span class="p">,</span> <span class="n">overhang</span><span class="p">);</span>
<a name="line-650"></a>			<span class="n">memcpy</span><span class="p">(</span><span class="n">first_block</span> <span class="o">+</span> <span class="n">overhang</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">md_block_size</span><span class="o">-</span><span class="n">overhang</span><span class="p">);</span>
<a name="line-651"></a>			<span class="n">md_transform</span><span class="p">(</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
<a name="line-652"></a>			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">/</span><span class="n">md_block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-653"></a>				<span class="n">md_transform</span><span class="p">(</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">md_block_size</span><span class="o">*</span><span class="n">i</span> <span class="o">-</span> <span class="n">overhang</span><span class="p">);</span>
<a name="line-654"></a>			<span class="p">}</span>
<a name="line-655"></a>		<span class="k">else</span>
<a name="line-656"></a>			<span class="p">{</span>
<a name="line-657"></a>			<span class="cm">/* k is a multiple of md_block_size. */</span>
<a name="line-658"></a>			<span class="n">memcpy</span><span class="p">(</span><span class="n">first_block</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
<a name="line-659"></a>			<span class="n">memcpy</span><span class="p">(</span><span class="n">first_block</span><span class="o">+</span><span class="mi">13</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">md_block_size</span><span class="o">-</span><span class="mi">13</span><span class="p">);</span>
<a name="line-660"></a>			<span class="n">md_transform</span><span class="p">(</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">first_block</span><span class="p">);</span>
<a name="line-661"></a>			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">/</span><span class="n">md_block_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-662"></a>				<span class="n">md_transform</span><span class="p">(</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="n">md_block_size</span><span class="o">*</span><span class="n">i</span> <span class="o">-</span> <span class="mi">13</span><span class="p">);</span>
<a name="line-663"></a>			<span class="p">}</span>
<a name="line-664"></a>		<span class="p">}</span>
<a name="line-665"></a>
<a name="line-666"></a>	<span class="n">memset</span><span class="p">(</span><span class="n">mac_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mac_out</span><span class="p">));</span>
<a name="line-667"></a>
<a name="line-668"></a>	<span class="cm">/* We now process the final hash blocks. For each block, we construct</span>
<a name="line-669"></a><span class="cm">	 * it in constant time. If the |i==index_a| then we&#39;ll include the 0x80</span>
<a name="line-670"></a><span class="cm">	 * bytes and zero pad etc. For each block we selectively copy it, in</span>
<a name="line-671"></a><span class="cm">	 * constant time, to |mac_out|. */</span>
<a name="line-672"></a>	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">num_starting_blocks</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">num_starting_blocks</span><span class="o">+</span><span class="n">variance_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-673"></a>		<span class="p">{</span>
<a name="line-674"></a>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">block</span><span class="p">[</span><span class="n">MAX_HASH_BLOCK_SIZE</span><span class="p">];</span>
<a name="line-675"></a>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">is_block_a</span> <span class="o">=</span> <span class="n">constant_time_eq_8</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index_a</span><span class="p">);</span>
<a name="line-676"></a>		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">is_block_b</span> <span class="o">=</span> <span class="n">constant_time_eq_8</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index_b</span><span class="p">);</span>
<a name="line-677"></a>		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">md_block_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
<a name="line-678"></a>			<span class="p">{</span>
<a name="line-679"></a>			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">is_past_c</span><span class="p">,</span> <span class="n">is_past_cp1</span><span class="p">;</span>
<a name="line-680"></a>			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">header_length</span><span class="p">)</span>
<a name="line-681"></a>				<span class="n">b</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<a name="line-682"></a>			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">data_plus_mac_plus_padding_size</span> <span class="o">+</span> <span class="n">header_length</span><span class="p">)</span>
<a name="line-683"></a>				<span class="n">b</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">header_length</span><span class="p">];</span>
<a name="line-684"></a>			<span class="n">k</span><span class="o">++</span><span class="p">;</span>
<a name="line-685"></a>
<a name="line-686"></a>			<span class="n">is_past_c</span> <span class="o">=</span> <span class="n">is_block_a</span> <span class="o">&amp;</span> <span class="n">constant_time_ge</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<a name="line-687"></a>			<span class="n">is_past_cp1</span> <span class="o">=</span> <span class="n">is_block_a</span> <span class="o">&amp;</span> <span class="n">constant_time_ge</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<a name="line-688"></a>			<span class="cm">/* If this is the block containing the end of the</span>
<a name="line-689"></a><span class="cm">			 * application data, and we are at the offset for the</span>
<a name="line-690"></a><span class="cm">			 * 0x80 value, then overwrite b with 0x80. */</span>
<a name="line-691"></a>			<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">&amp;~</span><span class="n">is_past_c</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mh">0x80</span><span class="o">&amp;</span><span class="n">is_past_c</span><span class="p">);</span>
<a name="line-692"></a>			<span class="cm">/* If this the the block containing the end of the</span>
<a name="line-693"></a><span class="cm">			 * application data and we&#39;re past the 0x80 value then</span>
<a name="line-694"></a><span class="cm">			 * just write zero. */</span>
<a name="line-695"></a>			<span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">&amp;~</span><span class="n">is_past_cp1</span><span class="p">;</span>
<a name="line-696"></a>			<span class="cm">/* If this is index_b (the final block), but not</span>
<a name="line-697"></a><span class="cm">			 * index_a (the end of the data), then the 64-bit</span>
<a name="line-698"></a><span class="cm">			 * length didn&#39;t fit into index_a and we&#39;re having to</span>
<a name="line-699"></a><span class="cm">			 * add an extra block of zeros. */</span>
<a name="line-700"></a>			<span class="n">b</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">is_block_b</span> <span class="o">|</span> <span class="n">is_block_a</span><span class="p">;</span>
<a name="line-701"></a>
<a name="line-702"></a>			<span class="cm">/* The final bytes of one of the blocks contains the</span>
<a name="line-703"></a><span class="cm">			 * length. */</span>
<a name="line-704"></a>			<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">md_block_size</span> <span class="o">-</span> <span class="n">md_length_size</span><span class="p">)</span>
<a name="line-705"></a>				<span class="p">{</span>
<a name="line-706"></a>				<span class="cm">/* If this is index_b, write a length byte. */</span>
<a name="line-707"></a>				<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">&amp;~</span><span class="n">is_block_b</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">is_block_b</span><span class="o">&amp;</span><span class="n">length_bytes</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="p">(</span><span class="n">md_block_size</span><span class="o">-</span><span class="n">md_length_size</span><span class="p">)]);</span>
<a name="line-708"></a>				<span class="p">}</span>
<a name="line-709"></a>			<span class="n">block</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<a name="line-710"></a>			<span class="p">}</span>
<a name="line-711"></a>
<a name="line-712"></a>		<span class="n">md_transform</span><span class="p">(</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
<a name="line-713"></a>		<span class="n">md_final_raw</span><span class="p">(</span><span class="n">md_state</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
<a name="line-714"></a>		<span class="cm">/* If this is index_b, copy the hash value to |mac_out|. */</span>
<a name="line-715"></a>		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">md_size</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
<a name="line-716"></a>			<span class="n">mac_out</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">|=</span> <span class="n">block</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&amp;</span><span class="n">is_block_b</span><span class="p">;</span>
<a name="line-717"></a>		<span class="p">}</span>
<a name="line-718"></a>
<a name="line-719"></a>	<span class="n">EVP_MD_CTX_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md_ctx</span><span class="p">);</span>
<a name="line-720"></a>	<span class="n">EVP_DigestInit_ex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md_ctx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">digest</span><span class="p">,</span> <span class="nb">NULL</span> <span class="cm">/* engine */</span><span class="p">);</span>
<a name="line-721"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">is_sslv3</span><span class="p">)</span>
<a name="line-722"></a>		<span class="p">{</span>
<a name="line-723"></a>		<span class="cm">/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */</span>
<a name="line-724"></a>		<span class="n">memset</span><span class="p">(</span><span class="n">hmac_pad</span><span class="p">,</span> <span class="mh">0x5c</span><span class="p">,</span> <span class="n">sslv3_pad_length</span><span class="p">);</span>
<a name="line-725"></a>
<a name="line-726"></a>		<span class="n">EVP_DigestUpdate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md_ctx</span><span class="p">,</span> <span class="n">mac_secret</span><span class="p">,</span> <span class="n">mac_secret_length</span><span class="p">);</span>
<a name="line-727"></a>		<span class="n">EVP_DigestUpdate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md_ctx</span><span class="p">,</span> <span class="n">hmac_pad</span><span class="p">,</span> <span class="n">sslv3_pad_length</span><span class="p">);</span>
<a name="line-728"></a>		<span class="n">EVP_DigestUpdate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md_ctx</span><span class="p">,</span> <span class="n">mac_out</span><span class="p">,</span> <span class="n">md_size</span><span class="p">);</span>
<a name="line-729"></a>		<span class="p">}</span>
<a name="line-730"></a>	<span class="k">else</span>
<a name="line-731"></a>		<span class="p">{</span>
<a name="line-732"></a>		<span class="cm">/* Complete the HMAC in the standard manner. */</span>
<a name="line-733"></a>		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">md_block_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a name="line-734"></a>			<span class="n">hmac_pad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="mh">0x6a</span><span class="p">;</span>
<a name="line-735"></a>
<a name="line-736"></a>		<span class="n">EVP_DigestUpdate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md_ctx</span><span class="p">,</span> <span class="n">hmac_pad</span><span class="p">,</span> <span class="n">md_block_size</span><span class="p">);</span>
<a name="line-737"></a>		<span class="n">EVP_DigestUpdate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md_ctx</span><span class="p">,</span> <span class="n">mac_out</span><span class="p">,</span> <span class="n">md_size</span><span class="p">);</span>
<a name="line-738"></a>		<span class="p">}</span>
<a name="line-739"></a>	<span class="n">EVP_DigestFinal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md_ctx</span><span class="p">,</span> <span class="n">md_out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">md_out_size_u</span><span class="p">);</span>
<a name="line-740"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">md_out_size</span><span class="p">)</span>
<a name="line-741"></a>		<span class="o">*</span><span class="n">md_out_size</span> <span class="o">=</span> <span class="n">md_out_size_u</span><span class="p">;</span>
<a name="line-742"></a>	<span class="n">EVP_MD_CTX_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md_ctx</span><span class="p">);</span>
<a name="line-743"></a>	<span class="p">}</span>
<a name="line-744"></a>
<a name="line-745"></a><span class="cp">#ifdef OPENSSL_FIPS</span>
<a name="line-746"></a>
<a name="line-747"></a><span class="cm">/* Due to the need to use EVP in FIPS mode we can&#39;t reimplement digests but</span>
<a name="line-748"></a><span class="cm"> * we can ensure the number of blocks processed is equal for all cases</span>
<a name="line-749"></a><span class="cm"> * by digesting additional data.</span>
<a name="line-750"></a><span class="cm"> */</span>
<a name="line-751"></a>
<a name="line-752"></a><span class="kt">void</span> <span class="nf">tls_fips_digest_extra</span><span class="p">(</span>
<a name="line-753"></a>	<span class="k">const</span> <span class="n">EVP_CIPHER_CTX</span> <span class="o">*</span><span class="n">cipher_ctx</span><span class="p">,</span> <span class="n">EVP_MD_CTX</span> <span class="o">*</span><span class="n">mac_ctx</span><span class="p">,</span>
<a name="line-754"></a>	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">data_len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">orig_len</span><span class="p">)</span>
<a name="line-755"></a>	<span class="p">{</span>
<a name="line-756"></a>	<span class="kt">size_t</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">digest_pad</span><span class="p">,</span> <span class="n">blocks_data</span><span class="p">,</span> <span class="n">blocks_orig</span><span class="p">;</span>
<a name="line-757"></a>	<span class="k">if</span> <span class="p">(</span><span class="n">EVP_CIPHER_CTX_mode</span><span class="p">(</span><span class="n">cipher_ctx</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EVP_CIPH_CBC_MODE</span><span class="p">)</span>
<a name="line-758"></a>		<span class="k">return</span><span class="p">;</span>
<a name="line-759"></a>	<span class="n">block_size</span> <span class="o">=</span> <span class="n">EVP_MD_CTX_block_size</span><span class="p">(</span><span class="n">mac_ctx</span><span class="p">);</span>
<a name="line-760"></a>	<span class="cm">/* We are in FIPS mode if we get this far so we know we have only SHA*</span>
<a name="line-761"></a><span class="cm">	 * digests and TLS to deal with.</span>
<a name="line-762"></a><span class="cm">	 * Minimum digest padding length is 17 for SHA384/SHA512 and 9</span>
<a name="line-763"></a><span class="cm">	 * otherwise.</span>
<a name="line-764"></a><span class="cm">	 * Additional header is 13 bytes. To get the number of digest blocks</span>
<a name="line-765"></a><span class="cm">	 * processed round up the amount of data plus padding to the nearest</span>
<a name="line-766"></a><span class="cm">	 * block length. Block length is 128 for SHA384/SHA512 and 64 otherwise.</span>
<a name="line-767"></a><span class="cm">	 * So we have:</span>
<a name="line-768"></a><span class="cm">	 * blocks = (payload_len + digest_pad + 13 + block_size - 1)/block_size</span>
<a name="line-769"></a><span class="cm">	 * equivalently:</span>
<a name="line-770"></a><span class="cm">	 * blocks = (payload_len + digest_pad + 12)/block_size + 1</span>
<a name="line-771"></a><span class="cm">	 * HMAC adds a constant overhead.</span>
<a name="line-772"></a><span class="cm">	 * We&#39;re ultimately only interested in differences so this becomes</span>
<a name="line-773"></a><span class="cm">	 * blocks = (payload_len + 29)/128</span>
<a name="line-774"></a><span class="cm">	 * for SHA384/SHA512 and</span>
<a name="line-775"></a><span class="cm">	 * blocks = (payload_len + 21)/64</span>
<a name="line-776"></a><span class="cm">	 * otherwise.</span>
<a name="line-777"></a><span class="cm">	 */</span>
<a name="line-778"></a>	<span class="n">digest_pad</span> <span class="o">=</span> <span class="n">block_size</span> <span class="o">==</span> <span class="mi">64</span> <span class="o">?</span> <span class="mi">21</span> <span class="o">:</span> <span class="mi">29</span><span class="p">;</span>
<a name="line-779"></a>	<span class="n">blocks_orig</span> <span class="o">=</span> <span class="p">(</span><span class="n">orig_len</span> <span class="o">+</span> <span class="n">digest_pad</span><span class="p">)</span><span class="o">/</span><span class="n">block_size</span><span class="p">;</span>
<a name="line-780"></a>	<span class="n">blocks_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">+</span> <span class="n">digest_pad</span><span class="p">)</span><span class="o">/</span><span class="n">block_size</span><span class="p">;</span>
<a name="line-781"></a>	<span class="cm">/* MAC enough blocks to make up the difference between the original</span>
<a name="line-782"></a><span class="cm">	 * and actual lengths plus one extra block to ensure this is never a</span>
<a name="line-783"></a><span class="cm">	 * no op. The &quot;data&quot; pointer should always have enough space to</span>
<a name="line-784"></a><span class="cm">	 * perform this operation as it is large enough for a maximum</span>
<a name="line-785"></a><span class="cm">	 * length TLS buffer. </span>
<a name="line-786"></a><span class="cm">	 */</span>
<a name="line-787"></a>	<span class="n">EVP_DigestSignUpdate</span><span class="p">(</span><span class="n">mac_ctx</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
<a name="line-788"></a>				<span class="p">(</span><span class="n">blocks_orig</span> <span class="o">-</span> <span class="n">blocks_data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">block_size</span><span class="p">);</span>
<a name="line-789"></a>	<span class="p">}</span>
<a name="line-790"></a><span class="cp">#endif</span>
</pre></div>
</td></tr></table>
      </div>
      <div id="footer">
        <p>
         Cppcheck 1.70 dev - a tool for static C/C++ code analysis</br>
         </br>
         Internet: <a href="http://cppcheck.sourceforge.net">http://cppcheck.sourceforge.net</a></br>
         IRC: <a href="irc://irc.freenode.net/cppcheck">irc://irc.freenode.net/cppcheck</a></br>
        <p>
      </div>
  </body>
</html>
